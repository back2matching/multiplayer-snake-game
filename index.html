<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; }
    </style>
</head>
<body>
    <script>
    const GRID_SIZE = 22;  // Increased to accommodate border
    const CELL_SIZE = 15;
    const GAME_WIDTH = GRID_SIZE * CELL_SIZE;
    const GAME_HEIGHT = GRID_SIZE * CELL_SIZE;

    let gameState = 'menu';
    let aiDifficulty = 'medium';

    const config = {
        type: Phaser.AUTO,
        width: GAME_WIDTH,
        height: GAME_HEIGHT,
        backgroundColor: '#000000',
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    const game = new Phaser.Game(config);
    let cursors;
    let player;
    let ai;
    let food;
    let playerScore = 0;
    let aiScore = 0;
    let scoreText;
    let gameOver = false;
    let startButton;
    let restartButton;
    let eatSound;
    let gameOverSound;
    let border;

    function preload() {
        this.load.audio('eat', 'https://opengameart.org/sites/default/files/audio_preview/Bite%20sound%20effect.mp3');
        this.load.audio('gameover', 'https://opengameart.org/sites/default/files/audio_preview/Life%20Lost%20-%20Game%20Over.mp3');
    }

    function create() {
        console.log("Create function called");
        cursors = this.input.keyboard.createCursorKeys();
        eatSound = this.sound.add('eat');
        gameOverSound = this.sound.add('gameover');
        createMenu(this);
    }

    function createMenu(scene) {
        console.log("Creating menu");
        scene.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000);
        scene.add.text(GAME_WIDTH/2, GAME_HEIGHT/4, 'Snake vs AI', { fontSize: '32px', fill: '#ffffff' }).setOrigin(0.5);
        
        let easyButton = scene.add.text(GAME_WIDTH/2 - 100, GAME_HEIGHT/2, 'Easy', { fontSize: '24px', fill: '#ffffff' })
            .setInteractive()
            .on('pointerdown', () => { aiDifficulty = 'easy'; startGame(scene); });
        
        let mediumButton = scene.add.text(GAME_WIDTH/2, GAME_HEIGHT/2, 'Medium', { fontSize: '24px', fill: '#ffffff' })
            .setOrigin(0.5)
            .setInteractive()
            .on('pointerdown', () => { aiDifficulty = 'medium'; startGame(scene); });
        
        let hardButton = scene.add.text(GAME_WIDTH/2 + 100, GAME_HEIGHT/2, 'Hard', { fontSize: '24px', fill: '#ffffff' })
            .setInteractive()
            .on('pointerdown', () => { aiDifficulty = 'hard'; startGame(scene); });
    }

    function startGame(scene) {
        console.log("Starting game");
        gameState = 'playing';
        playerScore = 0;
        aiScore = 0;
        gameOver = false;

        // Clear the screen
        scene.children.removeAll();

        // Create border
        border = scene.add.group();
        for (let x = 0; x < GRID_SIZE; x++) {
            for (let y = 0; y < GRID_SIZE; y++) {
                if (x === 0 || x === GRID_SIZE - 1 || y === 0 || y === GRID_SIZE - 1) {
                    border.add(scene.add.rectangle(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE, CELL_SIZE, 0xffff00));
                }
            }
        }
        
        player = {
            body: [scene.add.rectangle(CELL_SIZE * 6, CELL_SIZE * 11, CELL_SIZE * 0.75, CELL_SIZE * 0.75, 0x00ff00)],
            direction: {x: 1, y: 0},
            nextDirection: {x: 1, y: 0}
        };

        ai = {
            body: [scene.add.rectangle(CELL_SIZE * 16, CELL_SIZE * 11, CELL_SIZE * 0.75, CELL_SIZE * 0.75, 0xff0000)],
            direction: {x: -1, y: 0}
        };

        food = scene.add.rectangle(0, 0, CELL_SIZE * 0.75, CELL_SIZE * 0.75, 0xffffff);
        spawnFood(scene);

        scoreText = scene.add.text(16, 16, 'Player: 0  AI: 0', { fontSize: '18px', fill: '#ffffff' });

        scene.time.addEvent({
            delay: 150,
            callback: moveSnakes,
            callbackScope: scene,
            loop: true
        });
    }

    function update() {
        if (gameState !== 'playing') return;

        if (cursors.left.isDown && player.direction.x === 0) {
            player.nextDirection = {x: -1, y: 0};
        } else if (cursors.right.isDown && player.direction.x === 0) {
            player.nextDirection = {x: 1, y: 0};
        } else if (cursors.up.isDown && player.direction.y === 0) {
            player.nextDirection = {x: 0, y: -1};
        } else if (cursors.down.isDown && player.direction.y === 0) {
            player.nextDirection = {x: 0, y: 1};
        }
    }

    function moveSnakes() {
        if (gameState !== 'playing') return;

        // Move player
        player.direction = player.nextDirection;
        moveSnake(player);
        if (checkCollision(player)) {
            endGame("AI");
            return;
        }

        // Move AI
        moveAI();
        moveSnake(ai);
        if (checkCollision(ai)) {
            endGame("Player");
            return;
        }

        // Check for food collision
        if (player.body[0].x === food.x && player.body[0].y === food.y) {
            eatFood(player);
        } else if (ai.body[0].x === food.x && ai.body[0].y === food.y) {
            eatFood(ai);
        }
    }

    function moveSnake(snake) {
        let x = snake.body[0].x + snake.direction.x * CELL_SIZE;
        let y = snake.body[0].y + snake.direction.y * CELL_SIZE;

        // Move body
        for (let i = snake.body.length - 1; i > 0; i--) {
            snake.body[i].x = snake.body[i-1].x;
            snake.body[i].y = snake.body[i-1].y;
        }

        // Move head
        snake.body[0].x = x;
        snake.body[0].y = y;
    }

    function moveAI() {
        let dx = food.x - ai.body[0].x;
        let dy = food.y - ai.body[0].y;

        if (Math.random() < getAIDifficultyChance()) {
            if (Math.abs(dx) > Math.abs(dy)) {
                ai.direction = {x: dx > 0 ? 1 : -1, y: 0};
            } else {
                ai.direction = {x: 0, y: dy > 0 ? 1 : -1};
            }
        } else {
            // Random movement
            let directions = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
            ai.direction = directions[Math.floor(Math.random() * directions.length)];
        }

        // Avoid immediate collision
        let nextX = ai.body[0].x + ai.direction.x * CELL_SIZE;
        let nextY = ai.body[0].y + ai.direction.y * CELL_SIZE;
        if (nextX <= CELL_SIZE || nextX >= GAME_WIDTH - CELL_SIZE * 2 || 
            nextY <= CELL_SIZE || nextY >= GAME_HEIGHT - CELL_SIZE * 2 ||
            ai.body.some((segment, index) => index > 0 && segment.x === nextX && segment.y === nextY)) {
            // Choose a random safe direction
            let directions = [{x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}];
            directions = directions.filter(dir => 
                !(nextX + dir.x * CELL_SIZE <= CELL_SIZE || nextX + dir.x * CELL_SIZE >= GAME_WIDTH - CELL_SIZE * 2 || 
                nextY + dir.y * CELL_SIZE <= CELL_SIZE || nextY + dir.y * CELL_SIZE >= GAME_HEIGHT - CELL_SIZE * 2)
            );
            if (directions.length > 0) {
                ai.direction = directions[Math.floor(Math.random() * directions.length)];
            }
        }
    }

    function getAIDifficultyChance() {
        switch(aiDifficulty) {
            case 'easy': return 0.3;
            case 'medium': return 0.6;
            case 'hard': return 0.9;
            default: return 0.6;
        }
    }

    function checkCollision(snake) {
        let head = snake.body[0];
        // Wall collision
        if (head.x <= CELL_SIZE || head.x >= GAME_WIDTH - CELL_SIZE * 2 || 
            head.y <= CELL_SIZE || head.y >= GAME_HEIGHT - CELL_SIZE * 2) {
            return true;
        }
        // Self collision
        for (let i = 1; i < snake.body.length; i++) {
            if (head.x === snake.body[i].x && head.y === snake.body[i].y) {
                return true;
            }
        }
        // Other snake collision
        let otherSnake = snake === player ? ai : player;
        return otherSnake.body.some(segment => head.x === segment.x && head.y === segment.y);
    }

    function spawnFood(scene) {
        let x, y;
        do {
            x = Phaser.Math.Between(2, GRID_SIZE - 3) * CELL_SIZE;
            y = Phaser.Math.Between(2, GRID_SIZE - 3) * CELL_SIZE;
        } while (player.body.some(segment => segment.x === x && segment.y === y) ||
                 ai.body.some(segment => segment.x === x && segment.y === y));
        food.x = x + CELL_SIZE / 2;
        food.y = y + CELL_SIZE / 2;
    }

    function eatFood(snake) {
        eatSound.play();
        if (snake === player) {
            playerScore += 10;
        } else {
            aiScore += 10;
        }
        scoreText.setText(`Player: ${playerScore}  AI: ${aiScore}`);

        let tail = snake.body[snake.body.length - 1];
        let newSegment = game.scene.scenes[0].add.rectangle(
            tail.x, tail.y, 
            CELL_SIZE * 0.75, CELL_SIZE * 0.75, 
            snake === player ? 0x00ff00 : 0xff0000
        );
        snake.body.push(newSegment);

        spawnFood(game.scene.scenes[0]);
    }

    function endGame(winner) {
        gameOverSound.play();
        gameState = 'gameOver';
        gameOver = true;
        game.scene.scenes[0].add.text(GAME_WIDTH/2, GAME_HEIGHT/2, `Game Over! ${winner} wins!`, 
            { fontSize: '32px', fill: '#ffffff' }).setOrigin(0.5);
        restartButton = game.scene.scenes[0].add.text(GAME_WIDTH/2, GAME_HEIGHT * 3/4, 'Restart', 
            { fontSize: '24px', fill: '#ffffff' })
            .setOrigin(0.5)
            .setInteractive()
            .on('pointerdown', () => {
                game.scene.scenes[0].scene.restart();
            });
    }
    </script>
</body>
</html>
